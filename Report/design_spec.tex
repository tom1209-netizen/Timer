\documentclass[11pt, a4paper]{article}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}

% Document Margins
\geometry{a4paper, total={170mm,257mm}, left=20mm, top=20mm}

% Hyperlink Setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

% Header and Footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Timer IP Design Specification}
\fancyfoot[C]{\thepage}

% Code Listing Style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{verilogstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=Verilog
}
\lstset{style=verilogstyle}

% Redefine \contentsname for clarity
\renewcommand{\contentsname}{Table of Contents}

\begin{document}

% ------------------------------------------------------------------------------
% TITLE PAGE
% ------------------------------------------------------------------------------
\begin{titlepage}
    \centering
    \vspace*{1cm}
    
    {\Huge \bfseries Timer IP Design Specification}
    
    \vspace{1.5cm}
    
    {\Large Fundamental IC Design and Verification}
    
    \vspace{2cm}
    
    \vfill
    
    \vspace{1cm}
    
    {\large Version 1.1}
    
    \vspace{0.5cm}
    
    {\large \today}
    
\end{titlepage}

\newpage

% ------------------------------------------------------------------------------
% TABLE OF CONTENTS
% ------------------------------------------------------------------------------
\tableofcontents
\newpage
\listoffigures
\listoftables
\newpage

% ------------------------------------------------------------------------------
% SECTION 1: OVERVIEW
% ------------------------------------------------------------------------------
\section{Overview}

\subsection{Introduction}
The Timer IP is a digital hardware block designed to generate accurate timing intervals and control the timing of various operations within a System on Chip (SoC). It functions as a programmable counter that can trigger interrupts upon reaching a user-defined value.

This module is customized from the CLINT (Core Local Interruptor) module of the RISC-V architecture. Its primary applications include, but are not limited to:
\begin{itemize}
    \item Generating periodic interrupts for an operating system's scheduler.
    \item Creating precise delays.
    \item Event generation and counting.
    \item Pulse Width Modulation (PWM) signal generation.
\end{itemize}
The timer is configured via an AMBA APB slave interface, making it easily integrable into modern SoC designs.

\subsection{Feature List}
The Timer IP provides a comprehensive set of features for timing and control:
\begin{itemize}
    \item \textbf{64-bit Count-up Timer:} A free-running 64-bit counter.
    \item \textbf{APB Slave Interface:} Configuration is managed through a standard APB bus interface with a 12-bit address space.
    \item \textbf{Programmable Counter Speed:} The counter can be driven by the system clock or a divided clock (programmable divisor up to 256).
    \item \textbf{Interrupt Support:} A maskable, level-triggered hardware interrupt can be generated.
    \item \textbf{Active-Low Asynchronous Reset.}
    \item \textbf{APB Wait State:} Supports a single-cycle wait state to improve timing flexibility.
    \item \textbf{APB Byte Access:} Allows the bus to write to individual bytes within a 32-bit register using write strobes.
    \item \textbf{APB Error Handling:} Provides an error response for prohibited register accesses.
    \item \textbf{Debug Halt Mode:} The counter can be stopped (halted) during system debug mode.
    \item \textbf{Automatic Counter Reset:} The counter is automatically cleared to its initial value when the timer is disabled.
\end{itemize}

\subsection{High-Level Architecture}
The Timer IP is composed of three main sub-blocks: an APB Slave Interface, a Register File, and the Core Timer Logic.

\begin{figure}[H]
    \centering
    % --- ACTION REQUIRED ---
    % Create an image named 'block_diagram.png' and place it in the same directory.
    % This image should show the main modules: APB Interface, Register File, and Core Timer Logic.
    \framebox[0.8\textwidth]{\rule{0pt}{6cm} \huge Block Diagram Placeholder}
    \caption{High-Level Block Diagram of the Timer IP}
    \label{fig:block_diagram}
\end{figure}

\begin{itemize}
    \item \textbf{APB Slave Interface:} This module decodes the APB signals to manage read/write access to the register file. It implements the logic for wait states, byte enables, and error responses.
    \item \textbf{Register File:} A set of registers that control the timer's operation and hold its status.
    \item \textbf{Core Timer Logic:} This block contains the 64-bit counter, the logic for clock division, the comparator for the interrupt trigger, and the debug halt logic.
\end{itemize}

\subsection{Interface Signals (IO Port List)}
The top module is named \texttt{timer\_top}.

\begin{table}[H]
    \centering
    \caption{IO Port List for timer\_top}
    \label{tab:io_ports}
    \begin{tabular}{@{}lccl@{}}
        \toprule
        \textbf{Signal Name} & \textbf{Width} & \textbf{Direction} & \textbf{Description} \\ \midrule
        \texttt{sys\_clk}      & 1              & Input              & System clock. All synchronous logic operates on its rising edge. \\
        \texttt{sys\_rst\_n}    & 1              & Input              & Active-low asynchronous reset. \\
        \multicolumn{4}{c}{\textbf{APB Slave Interface}} \\
        \texttt{tim\_paddr}    & 12             & Input              & APB address bus. Selects a register within the Timer IP. \\
        \texttt{tim\_psel}     & 1              & Input              & APB select signal. Indicates the Timer IP is selected. \\
        \texttt{tim\_penable}  & 1              & Input              & APB enable signal. Latches address and control in the access phase. \\
        \texttt{tim\_pwrite}   & 1              & Input              & APB write control. 1 for write, 0 for read. \\
        \texttt{tim\_pwdata}   & 32             & Input              & APB write data bus. \\
        \texttt{tim\_prdata}   & 32             & Output             & APB read data bus. \\
        \texttt{tim\_pready}   & 1              & Output             & APB ready signal. Can be held low for one cycle to insert a wait state. \\
        \texttt{tim\_pslverr}  & 1              & Output             & APB slave error. Indicates an unsuccessful transfer. \\
        \texttt{tim\_pstrb}    & 4              & Input              & APB write strobes for byte-level write access. \\
        \multicolumn{4}{c}{\textbf{Timer Signals}} \\
        \texttt{tim\_int}      & 1              & Output             & Timer interrupt signal. Asserted when counter matches compare value. \\
        \texttt{dbg\_mode}     & 1              & Input              & Debug mode signal. Used to enable the halt functionality. \\ \bottomrule
    \end{tabular}
\end{table}

% ------------------------------------------------------------------------------
% SECTION 2: REGISTER SPECIFICATION
% ------------------------------------------------------------------------------
\section{Register Specification}

\subsection{Register Summary}
\begin{table}[H]
    \centering
    \caption{Register Summary}
    \label{tab:reg_summary}
    \begin{tabular}{@{}lll@{}}
        \toprule
        \textbf{Address Offset} & \textbf{Abbreviation} & \textbf{Register Name} \\ \midrule
        0x000 & TCR & Timer Control Register \\
        0x004 & TDR0 & Timer Data Register 0 (Counter bits [31:0]) \\
        0x008 & TDR1 & Timer Data Register 1 (Counter bits [63:32]) \\
        0x00C & TCMP0 & Timer Compare Register 0 (Compare bits [31:0]) \\
        0x010 & TCMP1 & Timer Compare Register 1 (Compare bits [63:32]) \\
        0x014 & TIER & Timer Interrupt Enable Register \\
        0x018 & TISR & Timer Interrupt Status Register \\
        0x01C & THCSR & Timer Halt Control Status Register \\
        Others & - & Reserved (Access is RAZ/WI) \\ \bottomrule
    \end{tabular}
\end{table}

\subsection{Detailed Register Descriptions}

\subsubsection{TCR - Timer Control Register (Offset: 0x000)}
\begin{table}[H]
    \centering
    \caption{TCR Bit Fields}
    \label{tab:tcr}
    \begin{tabular}{@{}llllll@{}}
        \toprule
        \textbf{Bit} & \textbf{Name} & \textbf{Type} & \textbf{Default} & \textbf{Description} \\ \midrule
        31:12 & Reserved & RO & 20'h0 & Reserved. Reads as 0. \\ \addlinespace
        11:8 & \texttt{div\_val} & RW & 4'b0001 & \textbf{Counter control mode setting.} See slide 15 for encoding. \\
        & & & & Writing a prohibited value generates an error response. \\ \addlinespace
        7:2 & Reserved & RO & 6'b0 & Reserved. Reads as 0. \\ \addlinespace
        1 & \texttt{div\_en} & RW & 1'b0 & \textbf{Counter control mode enable.} 1: Enabled. \\ \addlinespace
        0 & \texttt{timer\_en} & RW & 1'b0 & \textbf{Timer enable.} 1: Enabled. H->L transition resets counter. \\ \bottomrule
    \end{tabular}
    \caption*{Note: Attempting to change \texttt{div\_val} or \texttt{div\_en} while \texttt{timer\_en} is High will generate an APB error response, and the write will be ignored.}
\end{table}

\subsubsection{TDR0/TDR1 - Timer Data Registers (Offsets: 0x004, 0x008)}
These two registers form the 64-bit counter value. The value is cleared to its initial default when \texttt{TCR.timer\_en} transitions from High to Low.
\begin{itemize}
    \item \textbf{TDR0 (0x004):} Lower 32 bits of the counter. Default: 32'h0000\_0000.
    \item \textbf{TDR1 (0x008):} Upper 32 bits of the counter. Default: 32'h0000\_0000.
\end{itemize}

\subsubsection{TCMP0/TCMP1 - Timer Compare Registers (Offsets: 0x00C, 0x010)}
These two registers hold the 64-bit value that is compared against the counter to generate an interrupt.
\begin{itemize}
    \item \textbf{TCMP0 (0x00C):} Lower 32 bits of the compare value. Default: 32'hFFFF\_FFFF.
    \item \textbf{TCMP1 (0x010):} Upper 32 bits of the compare value. Default: 32'hFFFF\_FFFF.
\end{itemize}

\subsubsection{TIER - Timer Interrupt Enable Register (Offset: 0x014)}
\begin{table}[H]
    \centering
    \caption{TIER Bit Fields}
    \begin{tabular}{@{}lllll@{}}
        \toprule
        \textbf{Bit} & \textbf{Name} & \textbf{Type} & \textbf{Default} & \textbf{Description} \\ \midrule
        31:1 & Reserved & RO & 31'h0 & Reserved. \\
        0 & \texttt{int\_en} & R/W & 1'b0 & \textbf{Timer interrupt enable:} 0: Disabled, 1: Enabled. \\ \bottomrule
    \end{tabular}
\end{table}

\subsubsection{TISR - Timer Interrupt Status Register (Offset: 0x018)}
\begin{table}[H]
    \centering
    \caption{TISR Bit Fields}
    \begin{tabular}{@{}lllll@{}}
        \toprule
        \textbf{Bit} & \textbf{Name} & \textbf{Type} & \textbf{Default} & \textbf{Description} \\ \midrule
        31:1 & Reserved & RO & 31'h0 & Reserved. \\
        0 & \texttt{int\_st} & RW1C & 1'b0 & \textbf{Interrupt pending bit.} Write 1 to clear. \\ \bottomrule
    \end{tabular}
\end{table}

\subsubsection{THCSR - Timer Halt Control Status Register (Offset: 0x01C)}
\begin{table}[H]
    \centering
    \caption{THCSR Bit Fields}
    \begin{tabular}{@{}lllll@{}}
        \toprule
        \textbf{Bit} & \textbf{Name} & \textbf{Type} & \textbf{Default} & \textbf{Description} \\ \midrule
        31:2 & Reserved & RO & 30'h0 & Reserved. \\ \addlinespace
        1 & \texttt{halt\_ack} & RO & 1'b0 & \textbf{Timer halt acknowledge:} 1 indicates timer is halted. \\ \addlinespace
        0 & \texttt{halt\_req} & RW & 1'b0 & \textbf{Timer halt request:} 1 requests the timer to halt. \\ \bottomrule
    \end{tabular}
\end{table}

% ------------------------------------------------------------------------------
% SECTION 3: FUNCTIONAL DESCRIPTION
% ------------------------------------------------------------------------------
\section{Functional Description}

\subsection{Counter Module}
The core is a 64-bit synchronous count-up counter that runs when \texttt{TCR.timer\_en} is 1.

\subsubsection{Counting Modes}
\begin{itemize}
    \item \textbf{Default Mode (\texttt{div\_en} = 0):} The counter increments on every rising edge of \texttt{sys\_clk}.
    \item \textbf{Control Mode (\texttt{div\_en} = 1):} The counter increments at a rate determined by \texttt{TCR.div\_val}.
\end{itemize}

\begin{figure}[H]
    \centering
    % --- ACTION REQUIRED ---
    % Create an image named 'counting_waveform.png' based on slide 27.
    \framebox[0.9\textwidth]{\rule{0pt}{6cm} \huge Counting Mode Waveform Placeholder}
    \caption{Example Waveform for Control Counting Mode}
    \label{fig:counting_waveform}
\end{figure}

\subsubsection{Halted (Debug) Mode}
The counter can be halted when:
\begin{enumerate}
    \item The input signal \texttt{dbg\_mode} is high.
    \item The \texttt{THCSR.halt\_req} bit is set to 1.
\end{enumerate}
The IP asserts \texttt{THCSR.halt\_ack} to confirm the halt. The counter stops but retains its value. To resume, software must clear the \texttt{halt\_req} bit.

\begin{figure}[H]
    \centering
    % --- ACTION REQUIRED ---
    % Create an image named 'halt_waveform.png' based on slide 10.
    \framebox[0.9\textwidth]{\rule{0pt}{5cm} \huge Halt Mode Timing Diagram Placeholder}
    \caption{Halted Mode Timing Diagram}
    \label{fig:halt_waveform}
\end{figure}

\subsection{Interrupt Module}
\begin{itemize}
    \item \textbf{Trigger:} The interrupt condition occurs when the counter value equals the compare value.
    \item \textbf{Status:} On trigger, \texttt{TISR.int\_st} is set to 1. It is cleared by a write-1-to-clear operation.
    \item \textbf{Output:} \texttt{tim\_int} = \texttt{TISR.int\_st} AND \texttt{TIER.int\_en}.
\end{itemize}

\subsection{APB Slave Interface}
The timer acts as an APB slave, responding to transactions from an APB master.
\begin{itemize}
    \item \textbf{Wait State:} \texttt{pready} can be held low for one clock cycle to extend a transaction.
    \item \textbf{Byte Access:} The 4-bit \texttt{pstrb} signal enables writing to specific byte lanes.
    \item \textbf{Error Handling:} \texttt{pslverr} is asserted for one cycle on prohibited accesses. When an error occurs, the write is ignored. Prohibited accesses include:
    \begin{itemize}
        \item Writing a reserved value to \texttt{TCR.div\_val}.
        \item Changing \texttt{TCR.div\_en} or \texttt{TCR.div\_val} while \texttt{TCR.timer\_en} is high.
    \end{itemize}
\end{itemize}

\begin{figure}[H]
    \centering
    % --- ACTION REQUIRED ---
    % Create a standard APB write/read timing diagram, possibly showing a wait state.
    \framebox[0.9\textwidth]{\rule{0pt}{5cm} \huge APB Waveform Placeholder}
    \caption{APB Read/Write Transaction}
    \label{fig:apb_waveform}
\end{figure}

\begin{figure}[H]
    \centering
    % --- ACTION REQUIRED ---
    % Create a logic diagram for your APB slave implementation.
    \framebox[0.8\textwidth]{\rule{0pt}{6cm} \huge APB Slave Logic Diagram Placeholder}
    \caption{APB Slave Logic Diagram}
    \label{fig:apb_logic}
\end{figure}

% ------------------------------------------------------------------------------
% SECTION 4: IMPLEMENTATION CONSIDERATIONS
% ------------------------------------------------------------------------------
\section{Implementation Considerations}

\subsection{Reset Strategy}
The IP uses a single active-low asynchronous reset, \texttt{sys\_rst\_n}. Upon reset, all registers and internal states must return to their specified default values.

\subsection{Clocking}
The entire IP operates in a single clock domain, \texttt{sys\_clk}. All synchronous logic is triggered on the rising edge of this clock.

% ------------------------------------------------------------------------------
% SECTION 5: VERIFICATION PLAN
% ------------------------------------------------------------------------------
\section{Verification Plan}

\subsection{Testbench Architecture}
The verification environment should consist of a DUT, an APB BFM (Bus Functional Model), a Monitor, a Scoreboard/Checker, and a Test Sequencer.

\subsection{Test Cases}
\begin{enumerate}
    \item \textbf{Register Access:} Verify all registers are accessible. Verify RAZ/WI for reserved addresses.
    \item \textbf{Timer Control:} Verify timer enable, disable, and auto-reset functionality.
    \item \textbf{Counting Modes:} Test default and all valid control counting modes.
    \item \textbf{Counter Overflow:} Ensure correct 64-bit wraparound.
    \item \textbf{Interrupt Generation:} Verify interrupt trigger, status, enable/mask, and clear mechanisms.
    \item \textbf{Halt Mode:} Verify entry, exit, and behavior of the halt mode.
    \item \textbf{APB Functionality:} Test byte strobes, wait states, and error responses under all specified conditions.
    \item \textbf{Concurrent Operations:} Test scenarios with simultaneous APB access, counter events, and halt requests.
\end{enumerate}

% ------------------------------------------------------------------------------
% APPENDIX A: EXAMPLE RTL CODE
% ------------------------------------------------------------------------------
\appendix
\section{Example Verilog Code Snippets}

\subsection{Conceptual Counter Logic}
\begin{lstlisting}[language=Verilog, caption=Conceptual 64-bit Counter Increment Logic]
// Internal 64-bit counter register
reg [63:0] counter_reg;

// Halt acknowledge signal from THCSR
wire halt_ack; 

// Signal to enable counter increment for the current cycle
wire increment_en; 

// Determine if an increment should occur
assign increment_en = (timer_en == 1'b1) && !halt_ack && (/* logic for div_val */);

// Counter logic
always @(posedge sys_clk or negedge sys_rst_n) begin
    if (!sys_rst_n) begin
        counter_reg <= 64'd0;
    // Handle automatic counter reset when timer_en goes from 1 -> 0
    end else if (timer_en_falling_edge) begin
        counter_reg <= 64'd0;
    end else if (apb_write_to_tdr) begin
        // Logic to handle direct writes to TDR0/TDR1 with byte strobes
        counter_reg <= new_tdr_value;
    end else if (increment_en) begin
        counter_reg <= counter_reg + 1;
    end
end
\end{lstlisting}

\end{document}